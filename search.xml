<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c语言内存布局]]></title>
    <url>%2F2018%2F06%2F14%2Fc%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[在Linux系统下一个c语言进程的内存布局 Linux平台下的虚拟内存管理写C程序时,我们经常会打印一个指针地址,说这个指针指向某某内存地址.可这些地址是真实物理内存地址吗?不是!这些只是虚拟内存地址.当一个C程序调入内存开始执行后,在内存中就会产生一个进程.而在多任务操作系统中每个进程都拥有一片属于自己的内存空间(内存沙盘),这个沙盘就是虚拟地址空间,在32位下是一个4GB的大小的地址块,这些虚拟地址通过页表映射到物理内存.但系统并不会真的一下分配给每一个进程4GB的物理内存空间的映射= =(不现实啊),这4GB只能是说逻辑地址,它会随着进程的真实需要自动扩展映射到物理内存空间,最大到4GB.4GB(地址0-0xFFFFFFFF)其中1GB必须保留给系统内核(这是Linux平台下),也就是说进程自身只能拥有3GB的地址(0-0xC0000000),如图代码区:程序(函数)代码所在,由编译而得到的二进制代码被载入至此.代码区是只读的!有执行权限.代码区一般都从0x08048000地址开始(linux下).值得注意的是,字符串字面值(如”Hello World”)就存储在这个区.数据段和BSS段:合称静态区(全局区),用来存储静态(全局)变量.区别是 前者(数据段)存储的是已初始化的静态(全局)变量,可读写.后者(BSS段)存储的是未初始化的静态(全局)变量,可读写.堆:自由存储区.不像全局变量和局部变量的生命周期被严格定义,堆区的内存分配和释放是由程序员所控制的.申请方式:C中是malloc函数,C++中是new标识符.栈:由系统自动分配和释放.存储局部(自动)变量. 一般说的堆栈,其实是指 栈!另外,值得注意的是,堆是由低地址向高地址分配空间;栈却是由高地址向低地址分配空间.下面这段代码进一步说明C程序中各数据的内存布局:123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int i1 = 10; //静态全局区(data段)int i2; //静态全局区(bss段)static int i3 = 30; //静态全局区(data段)const int i4 = 40; //代码区!!!void fun(int i5) //栈区&#123; int i6 = 60; //栈区 static int i7 = 70; //静态全局区(data段) const int i8 = 80; //栈区!!! char* str1 = &quot;ABCDE&quot;; //代码区(字符串常量) char str2[] = &quot;ABCDE&quot;; //栈区(字符数组) int* pi = malloc(sizeof(int)); //堆区 printf(&quot;&amp;i5=%p\n&quot;, &amp;i5); printf(&quot;&amp;i6=%p\n&quot;, &amp;i6); printf(&quot;&amp;i7=%p\n&quot;, &amp;i7); printf(&quot;&amp;i8=%p\n&quot;, &amp;i8); printf(&quot;str1=%p\n&quot;, str1); printf(&quot;str2=%p\n&quot;, str2); printf(&quot;pi=%p\n&quot;, pi); free(pi);&#125;int main(void)&#123; printf(&quot;&amp;i1=%p\n&quot;, &amp;i1); printf(&quot;&amp;i2=%p\n&quot;, &amp;i2); printf(&quot;&amp;i3=%p\n&quot;, &amp;i3); printf(&quot;&amp;i4=%p\n&quot;, &amp;i4); fun(50); return 0;&#125; 程序输出:至此,从地址大小比较可以看出1)静态(static)全局变量 和 静态(static)局部变量 都在 静态全局区.2)全局常量i4保存在代码区,而局部常量i8保存在栈区.所以最上面的问题是,代码区只读,修改全局常量会引发运行时段错误,而局部常量是可以成功赋值修改的.3)字符串字面值在代码区(所以不可修改),但是字符指针str1在栈区;字符数组str2在栈区(所以可以修改). 堆和栈的区别 管理方式：对于栈来讲，是由编译器自动管理；对于堆来说，释放工作由程序员控制，容易产生 memory leak。 空间大小：一般来讲在 32 位系统下，堆内存可以达到接近 4G 的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在 VC6 下面，默认的栈空间大小大约是 1M。 碎片问题：对于堆来讲，频繁的new/delete 势必会造成内存空间的不连续，从而造成大量碎片，使程序效率降低；对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 分配方式：堆都是动态分配的，没有静态分配的堆；栈有 2 种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配，动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，不需要我们手工实现。 分配效率：栈是机器系统提供的数据结构，计算机会在底层分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高； 堆则是 C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，然后进行返回。显然，堆的效率比栈要低得多。 无论是堆还是栈，都要防止越界现象的发生。 关于 Global 和 Static 类型的一点讨论 static 全局变量与普通的全局变量有什么区别 ?全局变量(外部变量)的定义之前再冠以 static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。static 全局变量只初使化一次，防止在其他文件单元中被引用。 static 局部变量和普通局部变量有什么区别 ？把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。static 局部变量只被初始化一次，下一次依据上一次结果值。 static 函数与普通函数有什么区别？static 函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.static 函数在内存中只有一份（.data），普通函数在每个被调用中维持一份拷贝。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见单词发音]]></title>
    <url>%2F2018%2F05%2F28%2Ffayin%2F</url>
    <content type="text"><![CDATA[中国程序员容易发音错误的单词 中国程序员容易发音错误的单词(点击喇叭可收听正确读音) 单词 正确发音 错误发音 access 🔊 ✅ [‘ækses] ❌ [ək’ses] agile 🔊 ✅ [‘ædʒaɪl] ❌ [ə’dʒaɪl] amazon 🔊 ✅ [‘æməzən] ❌ [‘əmeizən; ə’meizən] analogy 🔊 ✅ [əˈnælədʒi] ❌ [ænə’lɒdʒi] Angular 🔊 ✅ [‘æŋgjʊlə] ❌ [‘æŋɡələ; ‘æŋdʒʌlə] AJAX 🔊 ✅ [‘eidʒæks] ❌ [ə’dʒʌks] alias 🔊 ✅ [ˈeɪliəs] ❌ [ə’lais] Apache 🔊 ✅ [ə’pætʃɪ] ❌ [ʌpʌtʃ] app 🔊 ✅ [æp] ❌ [eipi’pi] archive 🔊 ✅ [‘ɑːkaɪv] ❌ [‘ətʃɪv] array 🔊 ✅ [ə’rei] ❌ [æ’rei] ASCII 🔊 ✅ [‘æski] ❌ [ɑːsk] aspect 🔊 ✅ [‘æspekt] ❌ [ə’spekt] avatar 🔊 ✅ [‘ævətɑː] ❌ [ə’vʌtɑ] Azure 🔊 ✅ [‘æʒə] ❌ [ˈæzʊʒə] bind 🔊 ✅ [baɪnd] ❌ [bɪnd] cache 🔊 ✅ [kæʃ] ❌ [kætʃ] Daemon 🔊 ✅ [‘diːmən] ❌ [[dæmən]] deny 🔊 ✅ [dɪ’naɪ] ❌ [‘dæni] deque 🔊 ✅ [‘dek] ❌ [di’kju] digest 🔊 ✅ n. [‘dɑɪdʒɛst] v. [dɑɪ’dʒɛst] ❌ [‘dɪgɛst] Django 🔊 ✅ [ˈdʒæŋɡoʊ] ❌ [diˈdʒæŋɡoʊ] doc 🔊 ✅ [dɒk] ❌ [daʊk] facade 🔊 ✅ [fə’sɑːd] ❌ [‘feikeid] fedora 🔊 ✅ [fɪ’dɔːrə] ❌ [‘fedərə] Git 🔊 ✅ [ɡɪt] ❌ [dʒɪt] GNU 🔊 ✅ [gnu:] GUI 🔊 ✅ [ˈɡui] Haskell 🔊 ✅ [ˈhæskəl] ❌ [hæˈskəl] height 🔊 ✅ [haɪt] ❌ [heɪt] hidden 🔊 ✅ [‘hɪdn] ❌ [‘haɪdn] image 🔊 ✅ [‘ɪmɪdʒ] ❌ [ɪ’meɪdʒ] integer 🔊 ✅ [‘ɪntɪdʒə] ❌ [ˈɪntaɪgə] issue 🔊 ✅ [‘ɪʃuː] ❌ [ˈaɪʃuː] Java 🔊 ✅ [‘dʒɑːvə] ❌ [‘dʒɑːvɑː] jpg(jpeg) 🔊 ✅ [‘dʒeɪpeɡ] ❌ [ˈdʒeɪˈpi:ˈdʒiː] lambda 🔊 ✅ [ˈlæmdə] ❌ [ˈlɒŋmdɑ] linear 🔊 ✅ [‘lɪnɪə] ❌ [‘laɪə] Linux 🔊 ✅ [‘lɪnəks] ❌ [ˈlɪnʌks; ˈlɪnjuːks] locale 🔊 ✅ [ləʊ’kɑːl] ❌ [ˈloʊk(ə)l] main 🔊 ✅ [meɪn] ❌ [mɪn] margin 🔊 ✅ [‘mɑːdʒɪn] ❌ [‘mʌgɪn] matrix 🔊 ✅ [ˈmeɪtrɪks] ❌ [ˈmɑ:trɪks] maven 🔊 ✅ [‘meɪvn] ❌ [‘maːvn] Microsoft 🔊 ✅ [‘maikrəusɔft] ❌ [‘mikrəusɔft] module 🔊 ✅ [‘mɒdjuːl] ❌ [‘məʊdl] nginx ✅ Engine X null 🔊 ✅ [nʌl] ❌ [naʊ] OS X ✅ OS ten phantom 🔊 ✅ [‘fæntəm] ❌ [‘pæntəm] parameter 🔊 ✅ [pə’ræmɪtə] ❌ [‘pærəmɪtə] putty 🔊 ✅ [ˈpʌti] ❌ [ˈpuːti] query 🔊 ✅ [‘kwɪəri] ❌ [‘kwaɪri] Qt 🔊 ✅ [kjuːt] Realm 🔊 ✅ [relm] ❌ [riəlm] resolved 🔊 ✅ [rɪ’zɒlvd] ❌ [rɪ’səʊvd] resort 🔊 ✅ [rɪˈzɔ:t] ❌ [rɪˈsɔ:t] retina 🔊 ✅ [‘retɪnə] ❌ [ri’tina] san jose 🔊 ✅ [sænhəu’zei] ❌ [sæn’ju:s] safari 🔊 ✅ [sə’fɑːrɪ] ❌ [sæfərɪ] scheme 🔊 ✅ [skiːm] ❌ [s’kæmə] SQL ✅ [ˈsiːkwəl]/[ˈesˈkjuːˈel] sudo ✅ [‘suːduː] suite 🔊 ✅ [swiːt] ❌ [sjuːt] typical 🔊 ✅ [‘tɪpɪkl] ❌ [‘taɪpɪkəl] Ubuntu 🔊 ✅ [ʊ’bʊntʊ] ❌ [juː’bʊntʊ] variable 🔊 ✅ [‘veəriəbl] ❌ [və’raiəbl] vue 🔊 ✅ [v’ju:] ❌ [v’ju:i] width 🔊 ✅ [wɪdθ] ❌ [waɪdθ] YouTube 🔊 ✅ [‘juː’tjuːb] ❌ [‘juː’tʊbɪ] 本着简单的原则, 又为了避免程序猿们出现选择困难症, ‘正确音标’采用了最接近有道词典音频的英式 DJ 音标, 不代表其唯一性.专业在线英语词典请参考知乎链接:在线英语词典哪个比较好? 参考资料 https://www.zhihu.com/question/19739907 https://www.v2ex.com/t/131094 https://www.v2ex.com/t/309350 https://www.v2ex.com/t/63781 https://www.v2ex.com/t/246033 https://www.v2ex.com/t/342087 读对了所有的单词？]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言tcp编程]]></title>
    <url>%2F2018%2F05%2F22%2Fc%E8%AF%AD%E8%A8%80tcp%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[C语言tcp编程，Linux系统实现下面是TCP通信的demo： ##服务器端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*socket tcp服务器端*/ #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #define SERVER_PORT 5555 /* 监听后，一直处于accept阻塞状态， 直到有客户端连接， 当客户端如数quit后，断开与客户端的连接 */ int main() &#123; //调用socket函数返回的文件描述符 int serverSocket; //声明两个套接字sockaddr_in结构体变量，分别表示客户端和服务器 struct sockaddr_in server_addr; struct sockaddr_in clientAddr; int addr_len = sizeof(clientAddr); int client; char buffer[200]; int iDataNum; //socket函数，失败返回-1 //int socket(int domain, int type, int protocol); //第一个参数表示使用的地址类型，一般都是ipv4，AF_INET //第二个参数表示套接字类型：tcp：面向连接的稳定数据传输SOCK_STREAM //第三个参数设置为0 if((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123; perror(&quot;socket&quot;); return 1; &#125; bzero(&amp;server_addr, sizeof(server_addr)); //初始化服务器端的套接字，并用htons和htonl将端口和地址转成网络字节序 server_addr.sin_family = AF_INET; server_addr.sin_port = htons(SERVER_PORT); //ip可是是本服务器的ip，也可以用宏INADDR_ANY代替，代表0.0.0.0，表明所有地址 server_addr.sin_addr.s_addr = htonl(INADDR_ANY); //对于bind，accept之类的函数，里面套接字参数都是需要强制转换成(struct sockaddr *) //bind三个参数：服务器端的套接字的文件描述符， if(bind(serverSocket, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0) &#123; perror(&quot;connect&quot;); return 1; &#125; //设置服务器上的socket为监听状态 if(listen(serverSocket, 5) &lt; 0) &#123; perror(&quot;listen&quot;); return 1; &#125; while(1) &#123; printf(&quot;Listening on port: %d\n&quot;, SERVER_PORT); //调用accept函数后，会进入阻塞状态 //accept返回一个套接字的文件描述符，这样服务器端便有两个套接字的文件描述符， //serverSocket和client。 //serverSocket仍然继续在监听状态，client则负责接收和发送数据 //clientAddr是一个传出参数，accept返回时，传出客户端的地址和端口号 //addr_len是一个传入-传出参数，传入的是调用者提供的缓冲区的clientAddr的长度，以避免缓冲区溢出。 //传出的是客户端地址结构体的实际长度。 //出错返回-1 client = accept(serverSocket, (struct sockaddr*)&amp;clientAddr, (socklen_t*)&amp;addr_len); if(client &lt; 0) &#123; perror(&quot;accept&quot;); continue; &#125; printf(&quot;\nrecv client data...n&quot;); //inet_ntoa ip地址转换函数，将网络字节序IP转换为点分十进制IP //表达式：char *inet_ntoa (struct in_addr); printf(&quot;IP is %s\n&quot;, inet_ntoa(clientAddr.sin_addr)); printf(&quot;Port is %d\n&quot;, htons(clientAddr.sin_port)); while(1) &#123; iDataNum = recv(client, buffer, 1024, 0); if(iDataNum &lt; 0) &#123; perror(&quot;recv&quot;); continue; &#125; buffer[iDataNum] = &apos;\0&apos;; if(strcmp(buffer, &quot;quit&quot;) == 0) break; printf(&quot;%drecv data is %s\n&quot;, iDataNum, buffer); send(client, buffer, iDataNum, 0); &#125; &#125; return 0; &#125; ##客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*socket tcp客户端*/ #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;errno.h&gt; #include &lt;netdb.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #define SERVER_PORT 5555 /* 连接到服务器后，会不停循环，等待输入， 输入quit后，断开与服务器的连接 */ int main() &#123; //客户端只需要一个套接字文件描述符，用于和服务器通信 int clientSocket; //描述服务器的socket struct sockaddr_in serverAddr; char sendbuf[200]; char recvbuf[200]; int iDataNum; if((clientSocket = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123; perror(&quot;socket&quot;); return 1; &#125; serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(SERVER_PORT); //指定服务器端的ip，本地测试：127.0.0.1 //inet_addr()函数，将点分十进制IP转换成网络字节序IP serverAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); if(connect(clientSocket, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) &lt; 0) &#123; perror(&quot;connect&quot;); return 1; &#125; printf(&quot;connect with destination host...\n&quot;); while(1) &#123; printf(&quot;Input your world:&gt;&quot;); scanf(&quot;%s&quot;, sendbuf); printf(&quot;\n&quot;); send(clientSocket, sendbuf, strlen(sendbuf), 0); if(strcmp(sendbuf, &quot;quit&quot;) == 0) break; iDataNum = recv(clientSocket, recvbuf, 200, 0); recvbuf[iDataNum] = &apos;\0&apos;; printf(&quot;recv data of my world is: %s\n&quot;, recvbuf); &#125; close(clientSocket); return 0; &#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php字符串操作]]></title>
    <url>%2F2018%2F05%2F14%2Fphp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍了php中利用explode函数分割字符串到数组分割字符串 //利用 explode 函数分割字符串到数组代码如下: 12345678$source = &quot;hello1,hello2,hello3,hello4,hello5&quot;;//按逗号分离字符串 $hello = explode(&apos;,&apos;,$source); for($index=0;$index&lt;count($hello);$index++) &#123; echo $hello[$index];echo &quot;&lt;/br&gt;&quot;; &#125; ?&gt; //split函数进行字符分割// 分隔符可以是斜线，点，或横线代码如下:12345&lt;?php $date = &quot;04/30/1973&quot;; list($month, $day, $year) = split (&apos;[/.-]&apos;, $date); echo &quot;Month: $month; Day: $day; Year: $year&lt;br /&gt;\n&quot;; ?&gt; 通过数组实现多条件查询的代码 代码如下:12345678910&lt;?php$keyword=&quot;asp php,jsp&quot;;$keyword=str_replace(&quot; &quot;,&quot; &quot;,$keyword);$keyword=str_replace(&quot; &quot;,&quot;,&quot;,$keyword);$keyarr=explode(&apos;,&apos;,$keyword); for($index=0;$index&lt;count($keyarr);$index++) &#123; $whereSql .= &quot; And (arc.title like &apos;%$keyarr[$index]%&apos; Or arc.keywords like &apos;%$keyarr[$index]%&apos;) &quot;;&#125; echo $whereSql;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[makefile学习]]></title>
    <url>%2F2018%2F05%2F09%2Fmakefile%2F</url>
    <content type="text"><![CDATA[Makeflie基本使用makefile是Linux中的一个工具用于在一个工程中处理文件依赖，用于自动编译 什么是makefile在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。 基本语句12345678910target（要生成的文件）: dependencies（被依赖的文件） 命令1 命令2 命令3 命令前面用的是“tab”而非空格。误用空格是初学者容易犯的错误！ 命令可以是任何一个shell能运行的命令。 . . 命令n可以使用“\”表示续行。注意，“\”之后不能有空格！ make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。 简单的实例123print.h#include&lt;stdio.h&gt;void printhello(); 12345print.c#include&quot;print.h&quot;void printhello()&#123; printf(&quot;Hello World\n&quot;);&#125; 123456main.c#include&quot;print.h&quot;int main()&#123; printhello(); return 0;&#125; 123456789101112makefilehelloworld : main.o print.o gcc -o helloworld main.o print.omian.o : main.c print.h gcc -c main.cprint.o : print.c print.h gcc -c print.cclean : rm helloworld main.o print.o 用变量替代123456789101112ojb=main.o print.ohelloworld : $(ojb) gcc -o helloworld $(ojb)mian.o : main.c print.h gcc -c main.cprint.o : print.c print.h gcc -c print.cclean : rm helloworld $(ojb) 由make自己推导命令12345678ojb=main.o print.ohelloworld : $(ojb) gcc -o helloworld $(ojb)mian.o : main.c print.hprint.o : print.c print.hclean : rm helloworld $(ojb)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言]]></title>
    <url>%2F2018%2F05%2F04%2Fc%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[vs中 未初始化的变量的值 0Xcc -858993460 烫”：关键词：vs 中 未 初始化 变量 值 0xcc 858993460 烫vc的debug版会把未初始化的指针自动初始化为0xcccccccc，而不是就让它随机去，那是因为debug版的目的是为了方便我们调试程序的，如果野指针的初值不确定，那么每次调试同一个程序就可能出现不一样的结果，比如这次程序崩掉，下次正常运行，再一次虽然没崩掉，但结果不对……那显然对我们解bug是非常不利的。 __asm{int 3}的一个用处是在exe中可中断，产生调试。int 3 相当于 debugbreak， 机器码就是cc。 当一个未初始化赋值的时候(至少是vc 下未初始化的内存)默认是0xcccccccc;，他在内存就默认保存为-858993460 即二进制的11001100 11001100 11001100 11001100； 十六进制的cccccccc;而汉字 “烫” 的编码恰好就是1100110011001100:]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用 Git 命令清单]]></title>
    <url>%2F2018%2F04%2F13%2Fgit%2F</url>
    <content type="text"><![CDATA[git 日常使用命令一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件1234567891011121314151617# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销123456789101112131415161718192021222324252627# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到工作区$ git checkout [commit] [file]# 恢复上一个commit的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 其他12# 生成一个可供发布的压缩包$ git archive]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背景美化]]></title>
    <url>%2F2018%2F04%2F11%2F%E8%83%8C%E6%99%AF%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[页面背景美化 实现背景图更换及平铺，以及引入动态背景（可交互） 静态background设置1、打开博客根目录/themes/next/source/css/_custom/custom.styl文件，编辑如下：1234567// Custom styles.body &#123; background-image: url(/images/background.png); background-attachment: fixed; // 不随屏幕滚动而滚动 background-repeat: repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: contain; // 等比例铺满屏幕&#125; 2、将背景图命名为background.png并放入主题根目录/images下动态可交互背景（js引入）1、打开博客根目录/themes/next/layout/_layout.swig文件，在之前添加代码如下：1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 属性说明： color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 2、打开博客根目录/themes/next/_config.yml，找到字段canvas_nest，将其置为true【如果没有找到该字段，请自行添加】3、hexo clean , hexo d -g可以看到效果~]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美化]]></title>
    <url>%2F2018%2F04%2F11%2F%E7%82%B9%E5%87%BB%2F</url>
    <content type="text"><![CDATA[点击特效 实现点击出现桃心效果在网址输入如下： http://7u2ss1.com1.z0.glb.clouddn.com/love.js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown用法]]></title>
    <url>%2F2018%2F04%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[Markdown用法Hexo 是使用Markdown标记语言的，以前没有接触此处学习并记录。 什么是MarkdownMarkdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 标题标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。#号后面应使用空格与标题分隔H1 :# 一级标题H2 :## 二级标题H3 :### 三级标题H4 :#### 四级标题H5 :##### 五级标题H6 :###### 六级标题 文本样式带星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加链接 :Title加粗 :Bold斜体字 :Italics删除线 :text高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格 列表 :* 添加星号成为一个新的列表项。引用 : 使用说明，要结束引用需要在引用部分结束后插入一个回车 内嵌代码 : alert(&#39;Hello World&#39;);画水平线 (HR) :——–列举 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 插入图片 不选中的框 选中的框 书写一个质能守恒公式[^LaTeX]$E=mc^2$ 代码高亮1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 绘制表格 左对齐 右对齐 居中 计算机 $1600 5 手机 $12 12 管线 $1 234]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
