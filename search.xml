<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[makefile学习]]></title>
    <url>%2F2018%2F05%2F09%2Fmakefile%2F</url>
    <content type="text"><![CDATA[Makeflie基本使用makefile是Linux中的一个工具用于在一个工程中处理文件依赖，用于自动编译 什么是makefile在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。 基本语句12345678910target（要生成的文件）: dependencies（被依赖的文件） 命令1 命令2 命令3 命令前面用的是“tab”而非空格。误用空格是初学者容易犯的错误！ 命令可以是任何一个shell能运行的命令。 . . 命令n可以使用“\”表示续行。注意，“\”之后不能有空格！ make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。 简单的实例123print.h#include&lt;stdio.h&gt;void printhello(); 12345print.c#include&quot;print.h&quot;void printhello()&#123; printf(&quot;Hello World\n&quot;);&#125; 123456main.c#include&quot;print.h&quot;int main()&#123; printhello(); return 0;&#125; 123456789101112makefilehelloworld : main.o print.o gcc -o helloworld main.o print.omian.o : main.c print.h gcc -c main.cprint.o : print.c print.h gcc -c print.cclean : rm helloworld main.o print.o 用变量替代123456789101112ojb=main.o print.ohelloworld : $(ojb) gcc -o helloworld $(ojb)mian.o : main.c print.h gcc -c main.cprint.o : print.c print.h gcc -c print.cclean : rm helloworld $(ojb) 由make自己推导命令12345678ojb=main.o print.ohelloworld : $(ojb) gcc -o helloworld $(ojb)mian.o : main.c print.hprint.o : print.c print.hclean : rm helloworld $(ojb)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言]]></title>
    <url>%2F2018%2F05%2F04%2Fc%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[vs中 未初始化的变量的值 0Xcc -858993460 烫”：关键词：vs 中 未 初始化 变量 值 0xcc 858993460 烫vc的debug版会把未初始化的指针自动初始化为0xcccccccc，而不是就让它随机去，那是因为debug版的目的是为了方便我们调试程序的，如果野指针的初值不确定，那么每次调试同一个程序就可能出现不一样的结果，比如这次程序崩掉，下次正常运行，再一次虽然没崩掉，但结果不对……那显然对我们解bug是非常不利的。 __asm{int 3}的一个用处是在exe中可中断，产生调试。int 3 相当于 debugbreak， 机器码就是cc。 当一个未初始化赋值的时候(至少是vc 下未初始化的内存)默认是0xcccccccc;，他在内存就默认保存为-858993460 即二进制的11001100 11001100 11001100 11001100； 十六进制的cccccccc;而汉字 “烫” 的编码恰好就是1100110011001100:]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用 Git 命令清单]]></title>
    <url>%2F2018%2F04%2F13%2Fgit%2F</url>
    <content type="text"><![CDATA[git 日常使用命令一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件1234567891011121314151617# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销123456789101112131415161718192021222324252627# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到工作区$ git checkout [commit] [file]# 恢复上一个commit的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 其他12# 生成一个可供发布的压缩包$ git archive]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背景美化]]></title>
    <url>%2F2018%2F04%2F11%2F%E8%83%8C%E6%99%AF%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[页面背景美化 实现背景图更换及平铺，以及引入动态背景（可交互） 静态background设置1、打开博客根目录/themes/next/source/css/_custom/custom.styl文件，编辑如下：1234567// Custom styles.body &#123; background-image: url(/images/background.png); background-attachment: fixed; // 不随屏幕滚动而滚动 background-repeat: repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: contain; // 等比例铺满屏幕&#125; 2、将背景图命名为background.png并放入主题根目录/images下动态可交互背景（js引入）1、打开博客根目录/themes/next/layout/_layout.swig文件，在之前添加代码如下：1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 属性说明： color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 2、打开博客根目录/themes/next/_config.yml，找到字段canvas_nest，将其置为true【如果没有找到该字段，请自行添加】3、hexo clean , hexo d -g可以看到效果~]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美化]]></title>
    <url>%2F2018%2F04%2F11%2F%E7%82%B9%E5%87%BB%2F</url>
    <content type="text"><![CDATA[点击特效 实现点击出现桃心效果在网址输入如下： http://7u2ss1.com1.z0.glb.clouddn.com/love.js然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown用法]]></title>
    <url>%2F2018%2F04%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[Markdown用法Hexo 是使用Markdown标记语言的，以前没有接触此处学习并记录。 什么是MarkdownMarkdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 标题标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。#号后面应使用空格与标题分隔H1 :# 一级标题H2 :## 二级标题H3 :### 三级标题H4 :#### 四级标题H5 :##### 五级标题H6 :###### 六级标题 文本样式带星号的文本样式，在原版Markdown标准中不存在，但在其大部分衍生标准中被添加链接 :Title加粗 :Bold斜体字 :Italics删除线 :text高亮 :==text==段落 : 段落之间空一行换行符 : 一行结束时输入两个空格 列表 :* 添加星号成为一个新的列表项。引用 : 使用说明，要结束引用需要在引用部分结束后插入一个回车 内嵌代码 : alert(&#39;Hello World&#39;);画水平线 (HR) :——–列举 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 插入图片 不选中的框 选中的框 书写一个质能守恒公式[^LaTeX]$E=mc^2$ 代码高亮1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 绘制表格 左对齐 右对齐 居中 计算机 $1600 5 手机 $12 12 管线 $1 234]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
